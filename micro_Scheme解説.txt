									2011-05-03 okada-n
●SECD 仮想マシンの構成

SECD マシンは 4 つのレジスタ (変数) S, E, C, D を持った仮想マシンである。

    * S (Stack) :	スタック
    * E (Environment) :	環境
    * C (Code) :	実行するコード列
    * D (Dump) :	ダンプ (他のレジスタの値を一時的に保存する)

スタック、環境、実行するコード列、ダンプはそれぞれリストで表され、レジスタ S, E, C, D は、
各リスト（へのポインタ）を保持する。


●SECD 仮想マシンの命令

micro Scheme で使用する SECD 仮想マシンの命令と機能を以下に示す。

SECD 仮想マシンの命令と機能
------------------------------------------------------------------------------------------
ld (i . j)	E レジスタの i 番目のフレームの j 番目の要素をスタックに積む。
ldc const	定数 const をスタックに積む。
ldg sym		大域変数 sym の値をスタックに積む。
ldf code	code からクロージャを生成してスタックに積む。
args n		関数呼び出し用の引数リストを作る。スタックから n 個の値を取り出してリストにし、
		そのリストをスタックに積む。
app		スタックに積まれているクロージャと引数リストを取り出して関数呼び出しを行う。
		s, e, c をダンプ d に保存する。
rtn		関数呼び出しから戻る。ダンプ d に保存されている s, e, c を復元する
sel ct cf	条件分岐。スタックトップの値が真ならば ct を実行する。偽ならば cf を実行する。
		続くコード列 c をダンプ d に保存する。
join		条件分岐から戻る。ダンプ d に保存されているコード列 c を復元する。
pop		スタックトップの値を取り除く。
def sym		値（関数その他）を定義する。スタックトップの値（関数定義の場合はクロージャ）を
		大域変数 sym にセットする。
stop		仮想マシンの実行を停止する。
------------------------------------------------------------------------------------------
defm sym	マクロを定義する。スタックトップの値（クロージャ）をマクロ化して大域変数 sym
		にセットする。
lset (i . j)	スタック上の値をE レジスタの i 番目のフレームの j 番目の局所変数にセットする。
		スタック上の値は消費されない。
gset sym	スタック上の値を大域変数 symにセットする。
		スタック上の値は消費されない。
------------------------------------------------------------------------------------------
ldct code	call/cc のあとに実行するコード code から継続を生成してスタックに積む。
args-ap n	apply用の引数リストを作る。スタックから1つのリストとn-1個の値を取り出し、
		値をリストの先頭に追加した新しいリストを作り、そのリストをスタックに積む。
------------------------------------------------------------------------------------------
selr ct cf	条件分岐。続くコード列 c をダンプ d に保存しない。
tapp		スタックに積まれているクロージャと引数リストを取り出して関数呼び出しを行う。
		s, e, c をダンプ d に保存しない。
------------------------------------------------------------------------------------------


●micro Schemeの基本機能

1.自己評価フォーム
---------------------------------------------------
整数		... -3, -2, -1, 0, 1, 2, 3  ...		(Common Lisp互換)
不動小数点数	... -1.e-33 , 0.0, 0.12, 1.e33 ...	(Common Lisp互換)
有理数		... -1/3, 1/2, 1/3, 10/3 ...		(Common Lisp互換)
文字列		"abcde", "ABCDE", "12345" ...		(Common Lisp互換)
文字		#\a, #\b, #\c #\0 #\1 ...		(Common Lisp互換)
ベクタ		#(1 2 3 4 5), #(1 2 3 #(4 5))		(Common Lisp互換)
---------------------------------------------------

2.定数(同名の大域変数を束縛している)
---------------------------------------------------
true		評価結果は自分自身になる	(論理値の"真")
false		評価結果は自分自身になる	(論理値の"偽")
nil		評価結果は自分自身になる	(null要素、リストの終端要素)
quit		評価結果は自分自身になる	(評価すると micro Scheme が終了する)
---------------------------------------------------

3.基本関数(同名の大域変数を束縛している)
---------------------------------------------------
car		リストの car 要素
cdr		リストの cdr 要素
cons		cons セルを作る
gensym		他と衝突しないシンボルを生成
eq?		同一のオブジェクト？
eqv?		値が等しい？
pair?		cons セル？
display		オブジェクトを表示
newline		改行
+		加算
-		減算
*		乗算
/		除算
=		数値が等しい？
<		数値が小さい？
>		数値が大きい？
<=		数値が小さいか等しい？
>=		数値が大きいか等しい？
---------------------------------------------------

4.スペシャルフォーム(文法要素であり、対応する大域変数を持たない)
---------------------------------------------------
quote		クオート(評価から保護)
if		条件分岐
lambda		ラムダ(関数表現用)
define		値または関数を定義(大域変数を束縛する)
define-macro	マクロを定義(大域変数を束縛する)
set!		ローカル変数または大域変数に値をセット
call/cc		継続を取得してラムダ式に渡す
apply		引数リストに関数を適用
---------------------------------------------------

5.拡張関数(ライブラリ mlib.scm で供給、同名の大域変数を束縛する)
---------------------------------------------------
null?		nil か？
not		論理値の否定
cadr		リストの cadr 要素
cdar		リストの cdar 要素
caar		リストの caar 要素
cddr		リストの cddr 要素
cadar		リストの cadar 要素
list		引数をリスト化
append		リストの結合
memq		リストの探索(eq? で比較)
memv		リストの探索(eqv? で比較)
assq		連結リストの探索(eq? で比較)
assv		連結リストの探索(eqv? で比較)
map		マップ
map-2		2つのリストに対するマップ
filter		フィルター
fold-right	右方向畳み込み
fold-left	左方向畳み込み
transfer	backquote 内で unquote, splice を展開
reverse		リストの反転
find-do		繰り返しからの脱出(サンプル)
map-check	高階関数からの脱出(サンプル)
flatten		再帰呼び出しからの脱出(サンプル)
make-iter	イテレータを生成
for-each-tree	木の高階関数
make-promise	(delay 用の) promise の生成
force		promise の実行
fact		階乗
tarai		tarai 関数
tak		tak 関数
tarai-delay	delay 付き tarai 関数
---------------------------------------------------

6.マクロ(ライブラリ mlib.scm で供給、同名の大域変数を束縛する)
---------------------------------------------------
backquote	バッククオート(マクロ展開対応の quote)
let		ローカル変数束縛
and		論理 and
or		論理 or
let*		順序付きローカル変数束縛
letrec		自己参照可能なローカル変数束縛
begin		順次実行
cond		条件分岐(多重分岐)
case		case 分岐
do		do ループ
delay		評価の遅延
---------------------------------------------------

7.拡張スペシャルフォーム(コード探索用、対応する大域変数を持たない)
---------------------------------------------------
code		(conde <Compiled Code>)		コンパイル済みコードの注入
						(評価結果の注入は quote で出来る)
macro-print	(macro-print)			マクロ展開表示(ON/OFF)
trace-print	(trace-print)			実行トレース表示(ON/OFF)
---------------------------------------------------

8.その他の拡張
---------------------------------------------------
本体コードの Shebang スクリプト化
スクリプト起動時にライブラリを自動読み込み
循環リスト表示に対応
---------------------------------------------------

9.その他
---------------------------------------------------
コンパイラに1ヶ所バグを見つけたので修正
(if 式の末尾再帰の最適化時に、else 節が無い場合の else 節のコードは
 join ではなく rtn で終わるべき)
---------------------------------------------------

10.やることリスト
---------------------------------------------------
・コンパイラと vm の自動テストを作るべき
  (これからいろいろいじった際に、コードが壊れていない事の検証のため)
---------------------------------------------------



以上、（岡田）

