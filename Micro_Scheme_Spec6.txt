									2013-11-13 okada-n
● SECD 仮想マシンの構成

SECD マシンは 4 つのレジスタ (変数) S, E, C, D を持った仮想マシンである。

    * S (Stack) :	スタック
    * E (Environment) :	環境
    * C (Code) :	実行するコード列
    * D (Dump) :	ダンプ (他のレジスタの値を一時的に保存する)

スタック、環境、実行するコード列、ダンプはそれぞれリストで表され、レジスタ S, E, C, D は、
各リスト（へのポインタ）を保持する。


● SECD 仮想マシンの命令

micro Scheme で使用する SECD 仮想マシンの命令と機能を以下に示す。

SECD 仮想マシンの命令と機能
------------------------------------------------------------------------------------------
ld (i . j)	E レジスタの i 番目のフレームの j 番目の要素をスタックに積む。
ldc const	定数 const をスタックに積む。
ldg sym		大域変数 sym の値をスタックに積む。
ldf code	code からクロージャを生成してスタックに積む。
args n		関数呼び出し用の引数リストを作る。スタックから n 個の値を取り出してリストにし、
		そのリストをスタックに積む。
app		スタックに積まれているクロージャと引数リストを取り出して関数呼び出しを行う。
		s, e, c をダンプ d に保存する。
rtn		関数呼び出しから戻る。ダンプ d に保存されている s, e, c を復元する
sel ct cf	条件分岐。スタックトップの値が真ならば ct を実行する。偽ならば cf を実行する。
		続くコード列 c をダンプ d に保存する。
join		条件分岐から戻る。ダンプ d に保存されているコード列 c を復元する。
pop		スタックトップの値を取り除く。
def sym		値（関数その他）を定義する。スタックトップの値（関数定義の場合はクロージャ）を
		大域変数 sym にセットする。
stop		仮想マシンの実行を停止する。
------------------------------------------------------------------------------------------
defm sym	マクロを定義する。スタックトップの値（クロージャ）をマクロ化して大域変数 sym
		にセットする。
lset (i . j)	スタック上の値をE レジスタの i 番目のフレームの j 番目の局所変数にセットする。
		スタック上の値は消費されない。
gset sym	スタック上の値を大域変数 symにセットする。
		スタック上の値は消費されない。
------------------------------------------------------------------------------------------
ldct code	call/cc のあとに実行するコード code から継続を生成してスタックに積む。
args-ap n	apply用の引数リストを作る。スタックから1つのリストとn-1個の値を取り出し、
		値をリストの先頭に追加した新しいリストを作り、そのリストをスタックに積む。
------------------------------------------------------------------------------------------
selr ct cf	条件分岐。続くコード列 c をダンプ d に保存しない。
tapp		スタックに積まれているクロージャと引数リストを取り出して関数呼び出しを行う。
		s, e, c をダンプ d に保存しない。
------------------------------------------------------------------------------------------
lisp基本関数	car, cdr, cons ... など。
------------------------------------------------------------------------------------------


● micro Scheme の基本機能

1.自己評価フォーム
---------------------------------------------------
整数		... -3, -2, -1, 0, 1, 2, 3  ...		(Common Lisp互換)
不動小数点数	... -1.e-33 , 0.0, 0.12, 1.e33 ...	(Common Lisp互換)
有理数		... -1/3, 1/2, 1/3, 10/3 ...		(Common Lisp互換)
複素数		#c(-1 1), #c(1 2), #c(2 -3)		(Common Lisp互換）
文字列		"abcde", "ABCDE", "12345" ...		(Common Lisp互換)
文字		#\a, #\b, #\c #\0 #\1 ...		(Common Lisp互換)
ベクタ		#(1 2 3 4 5), #(1 2 3 #(4 5))		(Common Lisp互換)
---------------------------------------------------

2.定数(同名の大域変数を束縛している)
---------------------------------------------------
true		評価結果は自分自身になる	(論理値の"真")
false		評価結果は自分自身になる	(論理値の"偽")
nil		評価結果は自分自身になる	(null要素、リストの終端要素)
quit		評価結果は自分自身になる	(評価すると micro Scheme が終了する)
---------------------------------------------------

3.基本関数(同名の大域変数を束縛している)
---------------------------------------------------
car			リストの car 要素
cdr			リストの cdr 要素
cons			cons セルを作る
set-car!		cons の car に破壊的に値をセット
set-cdr!		cons の cdr に破壊的に値をセット
list			list を作る
null?			null か？
not			論理否定
gensym			他と衝突しないシンボルを生成
eq?			同一のオブジェクト？
eqv?			同一のオブジェクトか数値として等しい？
equal?			等価なオブジェクト？
pair?			cons セル？
display			オブジェクトを表示
newline			改行
+			加算
-			減算
*			乗算
/			除算
modulo			乗除
=			数値が等しい？
<			数値が小さい？
>			数値が大きい？
<=			数値が小さいか等しい？
>=			数値が大きいか等しい？
print			ディスプレイに値を1つ書き出す
read			キーボードから式を1つ読み込む
open-input-file		入力用にファイルを開く
open-output-file	出力用にファイルを開く
close-inout-port	入力用ファイルを閉じる
close-output-port	出力用ファイルを閉じる
read-line		ファイルから1行読込む
write			ファイルに文字列を書き出す
write_newline		ファイルに改行を書き出す
eof-object?		ファイルエンドか？
read-char		ファイルから1文字読み込む
write-char		ファイルに1文字書き出す
load			Scheme ファイルをロード
read-expr		ファイルから式を1つ読み込む
system			コマンド(フルパス)、オプション、ファイルリスト
			を指定してシステムコマンドを実行
macroexpand-1		1段マクロ展開を行う
macroexpand		可能な限りマクロ展開を行う
---------------------------------------------------

4.スペシャルフォーム(文法要素であり、対応する大域変数を持たない)
---------------------------------------------------
quote		クオート(評価から保護)
if		条件分岐
lambda		ラムダ(関数表現用)
define		値または関数を定義(大域変数を束縛する)
		関数定義の形式は、
		(define func (lambda (args) body)) 又は
		(define (func args) body)
define-macro	マクロを定義(大域変数を束縛する)
set!		ローカル変数または大域変数に値をセット
call/cc		継続を取得してラムダ式に渡す
apply		引数リストに関数を適用
---------------------------------------------------

5.拡張関数(ライブラリ mlib.scm で供給、同名の大域変数を束縛する)
---------------------------------------------------
caar		リストの caar 要素
cdar		リストの cdar 要素
cadr		リストの cadr 要素
cddr		リストの cddr 要素
caaar		リストの caaar 要素
cdaar		リストの cdaar 要素
cadar		リストの cadar 要素
cddar		リストの cddar 要素
caadr		リストの caadr 要素
cdadr		リストの cdadr 要素
caddr		リストの caddr 要素
cdddr		リストの cdddr 要素
append		リストの結合
memq		リストの探索(eq? で比較)
memv		リストの探索(eqv? で比較)
assq		連結リストの探索(eq? で比較)
assv		連結リストの探索(eqv? で比較)
map		マップ
map-2		2つのリストに対するマップ
filter		フィルター
fold-right	右方向畳み込み
fold-left	左方向畳み込み
transfer	backquote 内で unquote, splice を展開
reverse		リストの反転
make-iter	イテレータを生成
for-each-tree	木の高階関数
make-promise	(delay 用の) promise の生成
force		promise の実行
fact		階乗
tarai		tarai 関数
tak		tak 関数
tarai-delay	delay 付き tarai 関数
---------------------------------------------------

6.マクロ(ライブラリ mlib.scm で供給、同名の大域変数を束縛する)
---------------------------------------------------
backquote	バッククオート(マクロ展開対応の quote)
let		ローカル変数束縛
and		論理 and
or		論理 or
let*		順序付きローカル変数束縛
letrec		自己参照可能なローカル変数束縛
begin		順次実行
cond		条件分岐(多重分岐)
case		case 分岐
do		do ループ
delay		評価の遅延
---------------------------------------------------

7.拡張スペシャルフォーム(コード探索用、対応する大域変数を持たない)
---------------------------------------------------
code		(conde <Compiled Code>)		コンパイル済みコードの注入
						(評価結果の注入は quote で出来る)
macro-print	(macro-print)			マクロ展開表示(ON/OFF)
trace-print	(trace-print)			実行トレース表示(ON/OFF)
compile-print	(compile-print)			コンパイル表示(ON/OFF)
test-start	(test-start)			テストスタート(ファイル読込み時のみ)
test-end	(test-end)			テスト終了＆統計情報表示(ファイル読込み時のみ)
---------------------------------------------------

8.その他の拡張
---------------------------------------------------
本体コードの Shebang スクリプト化
起動時にライブラリを自動読み込み
循環リスト表示に対応
起動時の自動テスト (test-case.scm 読込みによる)
---------------------------------------------------

9.その他
---------------------------------------------------
コンパイラに1ヶ所バグを見つけたので修正
(if 式の末尾再帰の最適化時に、else 節が無い場合の else 節のコードは
 join ではなく rtn で終わるべき)
---------------------------------------------------

10.やることリスト
---------------------------------------------------
・コンパイラと vm の自動テストを作るべき
  (これからいろいろいじった際に、コードが壊れていない事の検証のため)
  -> 作った（test-case.scm）。
---------------------------------------------------



以上、（岡田）

